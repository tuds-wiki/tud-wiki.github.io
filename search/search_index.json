{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the TUD-SUMO Wiki!","text":"<p>This is the documentation for the TUD-SUMO package, a research-oriented wrapper for SUMO<sup>[1]</sup>, developed for the DIAMoND lab at the Technische Universiteit Delft (TUD), the Netherlands.</p> <p>The main goal of TUD-SUMO is to act as a simplified framework for microscopic traffic simulation that allows researchers and students to focus on the important aspects of their projects; their own work, instead of simulation code. TUD-SUMO provides an easy and standardised way to simulate a wide range of scenarios whilst facilitating complex interactions. Resulting data can then be saved, summarised and visualised with minimal code.</p> <p>More information on \"Simulation of Urban MObility\" (SUMO) can be found in the SUMO documentation, here: sumo.dlr.de/docs/</p> <p>The main features of TUD-SUMO include:</p> <ul> <li>Automatic and standardised data collection.</li> <li>Simple interface to interact with and control the simulation.</li> <li>Traffic signal control logic.</li> <li>Extendable controllers already implemented (ramp metering, route guidance and variable speed limits).</li> <li>An event system with dynamic or scheduled incidents.</li> <li>Plotting functions for a wide range of applications.</li> <li>And more in the future!</li> </ul> <p></p>"},{"location":"#links","title":"Links","text":"<ol> <li>Simulation of Urban MObility (SUMO) documentation: sumo.dlr.de/docs/</li> <li>TUD-SUMO source code: github.com/tud-sumo/tud_sumo</li> <li>TUD-SUMO PyPI distribution: pypi.org/project/tud-sumo/</li> <li>TUD-SUMO example: github.com/tud-sumo/example</li> </ol>"},{"location":"#latest-version","title":"Latest Version","text":"<p>The Latest version of TUD-SUMO is v3.0.8, and was released on 02/08/2024. The changenotes for this version are:</p>"},{"location":"#paths-vehicle-functions-update","title":"Paths &amp; Vehicle Functions Update","text":""},{"location":"#changes-improvements","title":"Changes &amp; Improvements","text":"<ul> <li>Added <code>Simulation.add_vehicle_in_funcs()</code> and <code>Simulation.add_vehicle_out_funcs()</code> to add functions called with each vehicle that enters/exits the simulation. Also added <code>Simulation.remove_vehicle_in_funcs()</code> and <code>Simulation.remove_vehicle_out_funcs()</code>.</li> <li>Added <code>Simulation.get_path_edges()</code> to calculate a route between two edges using the A* algorithm.</li> <li>Added <code>Simulation.get_path_travel_time()</code>, <code>Simulation.is_valid_path()</code> and <code>Simulation.add_route()</code>.</li> <li>Added <code>Plotter.plot_trip_time_histogram()</code> to plot trip time distribution.</li> <li>Added <code>Plotter.plot_throughput()</code> to plot throughput (rate of completed trips).</li> <li>Added <code>aggregation_steps</code> to <code>Plotter.plot_[vehicle/detector]_data()</code>, to aggregate/smooth data when plotting.</li> <li>Changed <code>line_colour</code> to a more general <code>plt_colour</code> in <code>Plotter</code> functions.</li> <li>More standardisation of docstrings/function definitions.</li> <li>Started implementing more standardised type checking (<code>validate_list_types()</code> and <code>validate_type()</code>).</li> </ul>"},{"location":"#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Fixed error where vehicle data was not being saved.</li> <li>Fixed <code>Simulation.get_geometry_vals()</code> function not recognising <code>\"length\"</code> as a valid data key.</li> <li>Fixed incorrect <code>\"curr_travel_time\"</code> and <code>\"ff_travel_time\"</code> calculations.</li> <li>Fixed <code>Plotter.plot_od_trip_times()</code> not using <code>vehicle_types</code> parameter.</li> <li>Removed TraCI calls from <code>RGController</code>.</li> </ul>"},{"location":"#contact","title":"Contact","text":"<p>TUD-SUMO is developed by Callum Evans in the DIAMoND lab of TU Delft. For any questions, feedback or bug reports, please contact Callum Evans or submit a query using the form here.</p>"},{"location":"#citations","title":"Citations","text":"<ol> <li>\"Microscopic Traffic Simulation using SUMO\"; Pablo Alvarez Lopez, Michael Behrisch, Laura Bieker-Walz, Jakob Erdmann, Yun-Pang Fl\u00f6tter\u00f6d, Robert Hilbrich, Leonhard L\u00fccken, Johannes Rummel, Peter Wagner, and Evamarie Wie\u00dfner. IEEE Intelligent Transportation Systems Conference (ITSC), 2018.</li> </ol>"},{"location":"2_getting_started/","title":"Getting Started","text":""},{"location":"2_getting_started/#requirements","title":"Requirements","text":"<p>To run TUD-SUMO, first install SUMO. Platform-specific information on how to do this can be found in the SUMO documentation: sumo.dlr.de/docs/Installing/</p> <p>Once SUMO has been installed, ensure that the <code>SUMO_HOME</code> variable has been set in your environment. This should be set to the base directory of your SUMO installation. Information on how to do this can be found here: sumo.dlr.de/docs/Basics/Basic_Computer_Skills.html</p> <p>Python 3.10 or later is required to run TUD-SUMO, otherwise, the required dependencies are:</p> <ul> <li><code>traci</code></li> <li><code>sumolib</code></li> <li><code>matplotlib</code></li> <li><code>mpl-tools</code></li> <li><code>shapely</code></li> <li><code>requests</code></li> <li><code>tqdm</code></li> </ul>"},{"location":"2_getting_started/#creating-an-environment","title":"Creating an Environment","text":"<p>It is recommended to use install the required packages in an environment, such as using Anaconda or Miniconda. A conda environment ready for TUD-SUMO can be created using the following commands.</p> <pre><code>conda create --name tud-sumo\nconda activate tud-sumo\nconda install matplotlib tqdm\npip install traci sumolib mpl-tools shapely requests\n</code></pre> <p>Conda can then be deactivated later using the command:</p> <pre><code>conda deactivate tud-sumo\n</code></pre>"},{"location":"2_getting_started/#installation","title":"Installation","text":"<p>TUD-SUMO is available on PyPI, and can be installed using the following command below. More information and previous release versions can be found on PyPI.</p> <pre><code>pip install tud-sumo\n</code></pre> <p>To install a specific version of TUD-SUMO, use:</p> <pre><code>pip install tud-sumo==3.0.4\n</code></pre>"},{"location":"3_basic_sim/","title":"Basic Simulations","text":""},{"location":"3_basic_sim/#sumo-scenarios","title":"SUMO Scenarios","text":"<p>Before anything can be simulated, all the necessary SUMO scenario files are required. This will typically include a '.sumocfg', '.neteditcfg', '.net.xml', '.rou.xml' and '.add.xml'. The simplest way to create a scenario and these files is using netedit, about which there is more information here.</p>"},{"location":"3_basic_sim/#initialising-the-simulation","title":"Initialising the Simulation","text":"<p>All simulations in TUD-SUMO are created and run using the <code>Simulation</code> class, which is initialised as below. A scenario name and description are optional, but can be useful when running multiple similar simulations.</p> <pre><code>from tud_sumo.simulation import Simulation\n\nmy_sim = Simulation(scenario_name=\"example\", scenario_desc=\"Example simulation.\")\n</code></pre> <p>To then start the simulation and create the connection to SUMO through TraCI, use <code>Simulation.start()</code>. This can very easily be done using the '.sumocfg' file created by netedit, which links all to all other files, however, the <code>net_file</code>, <code>route_file</code> and <code>add_file</code> parameters can also be used to give each file individually. Whether or not to use the GUI is also set here, although note this cannot be changed throughout the simulation.</p> <pre><code>my_sim.start(\"example_scenario.sumocfg\",\n             gui=True,\n             get_individual_vehicle_data=False,\n             units=\"metric\",\n             seed=1\n            )\n</code></pre> <p>The <code>get_individual_vehicle_data</code> is an important parameter denoting whether to collect and save dynamic information for all vehicles (ie. position, speed, acceleration etc.) at each step. This can be useful for small scenarios where this data may be required and computation time is less of an issue, such as single intersections, however, this should be set to false for large scenarios, such as large motorway networks.</p> <p>3 unit settings are supported 'metric' (km/kmph), 'imperial' (mi/mph) and 'UK' (km/mph). All data collected and saved are in these units, and this setting cannot be changed later.</p> <p>The <code>seed</code> parameter is optional and affects both the SUMO simulation and the <code>Simulation</code> class. Random seeds in SUMO primarily affects how vehicles are added into the simulation (more information can be found here). The seed can be set to random either by not using the parameter or by setting it to 'random'.</p> <p>Tracked junctions/edges, controllers etc. can be added at this point. These objects can be added individually, or if all parameters are saved in a dictionary or '.json' or '.pkl' file, these can be read using the <code>Simulation.load_objects()</code> function. More information on these objects can be found in their respective sections.</p> <pre><code>my_sim.load_objects(\"parameters.json\")\n</code></pre>"},{"location":"3_basic_sim/#adding-demand","title":"Adding Demand","text":"<p>There are two approaches to adding demand to a simulation. The default approach is to define demand with routes or by flow within a '.rou.xml' file, in which case, nothing else needs to be done. Alternatively, demand can be generated more dynamically within TUD-SUMO. This is done with either the <code>Simulation.load_demand()</code> or <code>Simulation.add_demand()</code> functions.</p> <p>Warning</p> <p>When adding demand using <code>Simulation.load_demand()</code> or <code>Simulation.add_demand()</code>, custom vehicle types and routes will still need to be pre-defined in a '.rou.xml' file. Any trips defined in this file will also still occur.</p> <p><code>Simulation.load_demand()</code> can be used to load a pre-defined demand profile from a '.csv' file, in the format below. For a route, either an 'origin' and 'destination' or a 'route_id' is required. If using a route ID, the route must be pre-defined in the '.rou.xml' file. A time range for the demand is also required, either with a 'start_time/end_time' or 'start_step/end_step'. The demand value can either be given as a flow value in vehicles/hour under 'demand' or as a raw number of vehicles under 'number'.</p> <p>If a flow value is given, vehicles are spawned throughout the demand period at this specified rate. Vehicles are inserted into the simulation using a Gaussian distribution with an average of 'demand' vehicle per hour. 'insertion_sd' is an optional float parameter that can be used to change the standard deviation of this distribution, and defaults to 1/3. Note that the actual standard deviation used is calculated using demand * insertion_sd. When the vehicles per step is below 1, vehicles are inserted at each step with this rate as a probability.</p> <p>The other parameters are optional. 'vehicle_types' can be a list of vehicle type IDs or a single ID and can optionally be given with 'vehicle_type_dists'. When adding demand of multiple potential vehicle types, this allows for the distribution of types to be defined. If 'vehicle_types', the default vehicle type is used, and when 'vehicle_types' is given without a 'vehicle_type_dists', vehicle types have an equal distribution. 'initial_speed' defines the initial speed of vehicles at insertion and can either be 'max', 'random' or a number &gt; 0, but defaults to 'max'. 'origin_lane' defines which lane vehicles are inserted at. This can either be 'random', 'free', 'allowed', 'best', 'first' or a specific lane index, but defaults to 'best'.</p> <p>Two examples of the contents of a 'demand.csv' file are shown below. It is possible to link a demand file in an object parameters dictionary under 'demand' when calling <code>Simulation.load_objects()</code>.</p> origin destination start_time end_time demand vehicle_types vehicle_type_dists edge_1 edge_10 0 600 1200 \"cars,vans,lorries\" \"0.7,0.2,0.1\" ... ... ... ... ... ... ... route_id start_step end_step number initial_speed origin_lane insertion_sd route_1 0 1200 200 max 1 0.3 ... ... ... ... ... ... ... <p>Otherwise, demand can be added in code using the <code>Simulation.add_demand()</code> function. This uses the same set of parameters as the demand files above, except 'origin/destination/route_id' is replaced by a single <code>routing</code> parameter, and <code>step_range</code> is used instead of 'start_time/end_time' or 'start_step/end_step'. Demand is also defined as a flow rate in vehicles/hour. Examples are shown below.</p> <pre><code>my_sim.add_demand(routing=(\"edge_1\", \"edge_10\"),\n                  step_range=(0, 1200),\n                  demand=1200,\n                  vehicle_types=[\"cars\", \"vans\", \"lorries\"],\n                  vehicle_type_dists=[0.7, 0.2, 0.2]\n                 )\n\nmy_sim.add_demand(routing=\"route_1\",\n                  step_range=(0, 1200),\n                  demand=200,\n                  initial_speed=\"max\",\n                  origin_lane=1\n                 )\n</code></pre> <p>Warning</p> <p>Adding demand dynamically (<code>Simulation.load_demand()</code> and <code>Simulation.add_demand()</code>) reduces performance compared to pre-defined demand in a '.rou.xml' file. Average trip times will also be longer as vehicles added this way are registered when they are loaded, not when they are inserted.</p>"},{"location":"3_basic_sim/#running-the-simulation","title":"Running the Simulation","text":"<p>The simulation is run using the <code>Simulation.step_through()</code> function. When no parameters are given, the simulation will run through one step by default. Otherwise, using <code>n_steps</code> will run the simulation for a specific number of steps, <code>end_step</code> will run the simulation until a specific step and <code>n_seconds</code> will run the simulation for a specific amount of time (in seconds).</p> <pre><code># Run 1 step\nmy_sim.step_through()\n\n# Run for 100 steps\nmy_sim.step_through(100)\n\n# Run until step 200\nmy_sim.step_through(end_step=200)\n\n# Run for 100 seconds (where step length = 0.5)\nmy_sim.step_through(n_seconds=200)\n</code></pre> <p>A control loop can, therefore, be created as below. A progress bar is automatically created when simulating for 10 or more steps in one call of <code>Simulation.step_through()</code>. In order to create a progress bar that is consistent between separate calls, use the <code>pbar_max_steps</code> parameter and set this to the total length of the simulation.</p> <pre><code>n, sim_dur = 100, 2500\nwhile my_sim.curr_step &lt; sim_dur:\n\n    # Step through n steps.\n    my_sim.step_through(n_steps=n, pbar_max_steps=sim_dur)\n\n    # Perform control\n    # ...\n</code></pre>"},{"location":"3_basic_sim/#ending-the-simulation","title":"Ending the Simulation","text":"<p>A simulation can be run until it is finished as below. The <code>Simulation.is_running()</code> function returns false once the simulation is over, which is determined as happening once all defined vehicles have finished their run through the simulation. It is then best to end the simulation using <code>Simulation.end()</code>, which closes the connection to TraCI.</p> <pre><code>while my_sim.is_running():\n    my_sim.step_through()\n\nmy_sim.end()\n</code></pre>"},{"location":"3_basic_sim/#automatic-data-collection","title":"Automatic Data Collection","text":"<p>One of the major advantages of TUD-SUMO is the automatic data collection. This involves automatically collecting all basic simulation information into a <code>sim_data</code> dictionary. An example of this can be seen in examples directory in the main TUD-SUMO repository, however, the main structure is as follows:</p> <pre><code>{\n    \"data\":\n        {\n            \"detectors\": {},\n            \"junctions\": {},\n            \"edges\": {},\n            \"controllers\": {},\n            \"vehicles\": {},\n            \"demand\": {},\n            \"trips\": {},\n            \"events\": {},\n            \"all_vehicles\": {}\n        },\n    \"start\": 0,\n    \"end\": 1000,\n    \"step_len\": 1.0,\n    \"units\": \"METRIC\",\n    \"seed\": 10,\n    \"sim_start\": \"08/07/2024, 13:00:00\",\n    \"sim_end\": \"08/07/2024, 13:00:10\"\n}\n</code></pre> <p>Detectors will automatically collect vehicle speeds and counts for each time step, as well as the IDs of each vehicle that passed over it, whilst occupancies are also collected for mutli-entry-exit detectors. These will be stored under 'data/detectors/{detector_id}', with 'type', 'position', 'speeds', 'vehicle_counts', 'vehicle_ids' and 'occupancies'.</p> <p>Vehicle data will include the number of vehicles at each step, 'tts' (N. vehicles * step length) and 'delay' (calculated as the time spent by vehicles waiting in each time step).</p> <p>Demand is only included when dynamically adding demand, ie. not when demand is solely defined in the '.rou.xml' file. This dictionary will contain two objects; 'headers' and a 'table'. 'table' will contain a (6 x n) sized array, with its headers listed under 'headers'. Only demand added through <code>Simulation.load_demand()</code> and <code>Simulation.add_demand()</code> will be included here.</p> <p>Trip data will contain data for incomplete and completed trips. This is stored under 'data/trips' and then either 'incomplete' or 'completed'. Each trip will store the 'route_id', 'vehicle_type', 'departure', 'arrival' (or removal), 'origin' and 'destination'.</p> <p>Junction, edge, controller and event data are only included when necessary. The <code>all_vehicles</code> data will contain all the individual vehicle data at each time step, so it is only included when <code>get_individual_vehicle_data</code> is set to true when starting the simulation.</p> <p>The <code>sim_data</code> dictionary can be reset at any point using the <code>Simulation.reset_data()</code> function.</p> <pre><code>my_sim.reset_data()\n</code></pre>"},{"location":"3_basic_sim/#saving-summarising-data","title":"Saving &amp; Summarising Data","text":"<p>All the data collected throughout the simulation can be saved at any point using the <code>Simulation.save_data()</code> function. This will save the <code>sim_data</code> dictionary as a file in the specified directory. Either JSON or pickle files are supported, simply denoted by a '.json' or '.pkl' extension in the filename.</p> <pre><code>my_sim.save_data(\"data/example_data.json\")\nmy_sim.save_data(\"data/example_data.pkl\")\n</code></pre> <p>All data saved by a simulation or a simulation data file can be summarised using the <code>Simulation.print_summary()</code> or <code>print_summary()</code> functions. This will print a summary of the collected data (ie. number of vehicles, TTS, controllers, events etc.), as well as some information about the simulation itself (ie. scenario name/description, runtime, seed etc.). This summary can be saved to a '.txt' file using the <code>save_file</code> parameter. An example summary is shown below.</p> <pre><code>my_sim.print_summary(save_file=\"data/example_summary.txt\")\n\n# Print summary without creating a Simulation object\nfrom tud_sumo.simulation import print_summary\nprint_summary(\"data/example_data.pkl\")\n</code></pre> <pre><code> *============================================================*\n |                          A20_ITCS                          | \n *============================================================*\n |                        Description:                        | \n |   Example traffic controllers, with 2 ramp meters, 1 VSL   | \n |        controller and 1 route guidance controller.         | \n *============================================================*\n |                 Simulation Run: 10/07/2024                 | \n |               12:02:14 - 12:02:25 (0:00:11)                | \n *------------------------------------------------------------*\n | Number of Steps:                                       500 | \n | Step Length:                                           1.0 | \n | Avg. Step Duration:                                 0.022s | \n | Units Type:                              Metric (km, km/h) | \n | Seed:                                                    1 | \n *============================================================*\n |                            Data                            | \n *============================================================*\n |                        Vehicle Data                        | \n *------------------------------------------------------------*\n | Avg. No. Vehicles:                                  774.66 | \n | Peak No. Vehicles:                                    1277 | \n | Avg. No. Waiting Vehicles:                           34.26 | \n | Peak No. Waiting Vehicles:                             104 | \n | Final No. Vehicles:                                   1277 | \n | Individual Data:                                        No | \n * ---------------------------------------------------------- *\n | Total TTS:                                       387332.0s | \n | Total Delay:                                      17132.0s | \n *------------------------------------------------------------*\n |                         Trip Data                          | \n *------------------------------------------------------------*\n | Incomplete Trips:                             1281 (67.2%) | \n | Completed Trips:                               625 (32.8%) | \n *------------------------------------------------------------*\n |                         Detectors                          | \n *------------------------------------------------------------*\n |               Induction Loop Detectors: (15)               | \n |       a13_ramp_inflow, cw_down_occ_0, cw_down_occ_1,       | \n |  cw_down_occ_2, cw_down_occ_3, cw_up_occ_0, cw_up_occ_1,   | \n |      cw_up_occ_2, rerouter_2, utsc_e_in, utsc_e_out,       | \n |      utsc_n_in_1, utsc_n_in_2, utsc_w_in, utsc_w_out       | \n |                                                            | \n |              Multi-Entry-Exit Detectors: (7)               | \n |    a13_ramp_queue, a13_rm_downstream, a13_rm_upstream,     | \n |      cw_ramp_inflow, cw_ramp_queue, cw_rm_downstream,      | \n |                       cw_rm_upstream                       | \n *------------------------------------------------------------*\n |                       Tracked Edges                        | \n *------------------------------------------------------------*\n | 126730026, 1191885773, 1191885771, 126730171, 1191885772,  | \n |         948542172, 70944365, 308977078, 1192621075         | \n *------------------------------------------------------------*\n |                     Tracked Junctions                      | \n *------------------------------------------------------------*\n |                     utsc (Signalised)                      | \n |           crooswijk_meter (Signalised, Metered)            | \n |              a13_meter (Signalised, Metered)               | \n *------------------------------------------------------------*\n |                        Controllers                         | \n *------------------------------------------------------------*\n |                    Route Guidance: (1)                     | \n |                          rerouter                          | \n |                                                            | \n |                 Variable Speed Limits: (1)                 | \n |                            vsl                             | \n *------------------------------------------------------------*\n |                    Event IDs &amp; Statuses                    | \n *------------------------------------------------------------*\n |                 Active: incident_response                  | \n |             Completed: incident_1, bottleneck              | \n *------------------------------------------------------------*\n</code></pre> <p>The structure of a simulation data file can also be printed using the <code>Simulation.print_sim_data_struct()</code> or <code>print_sim_data_struct()</code> functions. This will print the structure of the <code>sim_data</code> dictionary as a tree, allowing you to see the exact keys and data types used in the data. An example of the output of <code>print_sim_data_struct()</code> is shown below.</p> <p>Note that the dimensions of array are only displayed up to 2D. If an array has a higher dimension, this is denoted by a '+'. If the array is inhomogeneous (ie. its dimensions are inconsistent), this is denoted by a '*' and the array's maximum size is shown.</p> <pre><code>my_sim.print_sim_data_struct()\n\n# Print structure without creating a Simulation object\nfrom tud_sumo.simulation import print_sim_data_struct\nprint_sim_data_struct(\"data/example_data.pkl\")\n</code></pre> <pre><code>A20_ITCS:\n  \u251c\u2500- scenario_name: str\n  \u251c\u2500- scenario_desc: str\n  \u251c\u2500- data:\n  |     \u251c\u2500- detectors:\n  |     |     \u251c\u2500- a13_ramp_queue:\n  |     |     |     \u251c\u2500- type: str\n  |     |     |     \u251c\u2500- position:\n  |     |     |     |     \u251c\u2500- entry_lanes: list (1x1)\n  |     |     |     |     \u251c\u2500- exit_lanes: list (1x1)\n  |     |     |     |     \u251c\u2500- entry_positions: list (1x1)\n  |     |     |     |     \u2514\u2500- exit_positions: list (1x1)\n  |     |     |     \u251c\u2500- speeds: list (1x500)\n  |     |     |     \u251c\u2500- vehicle_counts: list (1x500)\n  |     |     |     \u251c\u2500- vehicle_ids: list (500x27*)\n  |     |     |     \u2514\u2500- occupancies: list (1x0)\n  .     .     .\n  .     .     .\n  .     .     .\n  |     \u251c\u2500- vehicles:\n  |     |     \u251c\u2500- no_vehicles: list (1x500)\n  |     |     \u251c\u2500- no_waiting: list (1x500)\n  |     |     \u251c\u2500- tts: list (1x500)\n  |     |     \u2514\u2500- delay: list (1x500)\n  |     \u251c\u2500- trips:\n  |     |     \u251c\u2500- incomplete: dict (1x1311)\n  |     |     \u2514\u2500- completed: dict (1x601)\n  |     \u2514\u2500- events:\n  |           \u251c\u2500- scheduled: list (1x1)\n  |           \u251c\u2500- active: list (1x1)\n  |           \u2514\u2500- completed: list (1x1)\n  \u251c\u2500- start: int\n  \u251c\u2500- end: int\n  \u251c\u2500- step_len: float\n  \u251c\u2500- units: str\n  \u251c\u2500- seed: int\n  \u251c\u2500- sim_start: str\n  \u2514\u2500- sim_end: str\n</code></pre>"},{"location":"4_interactions/","title":"Interacting with the Simulation","text":""},{"location":"4_interactions/#testing-values","title":"Testing Values","text":"<p>Several functions exist to check values in the simulation, primarily to check wether objects exist and get their type or status. All of these are within the <code>Simulation</code> class, and are:</p>"},{"location":"4_interactions/#vehicles","title":"Vehicles","text":"Function Return Value <code>vehicle_exists(ID)</code> Whether or not a vehicle with the given ID exists in the simulation. <code>vehicle_loaded(ID)</code> Whether or not a vehicle has been scheduled to enter (or is already in) the simulation. <code>vehicle_to_depart(ID)</code> Whether or not a vehicle has been scheduled to enter (but is not in) the simulation. <code>vehicle_type_exists(ID)</code> Whether or not a vehicle type with the given ID exists. <code>route_exists(ID)</code> Route edges if the ID exists, else returns None."},{"location":"4_interactions/#other-objects","title":"Other Objects","text":"Function Return Value <code>detector_exists(ID)</code> Detector type if the ID exists, else returns None. <code>controller_exists(ID)</code> Whether a controller with the ID exists. <code>event_exists(ID)</code> Event status if the ID exists, else returns None. <code>geometry_exists(ID)</code> Geometry type if ID exists (lane/edge), else returns None. <code>tracked_edge_exists(ID)</code> Whether a tracked edge with the ID exists. <code>junction_exists(ID)</code> Whether a junction with the ID exists. <code>tracked_junction_exists(ID)</code> Whether a tracked junction with the ID exists."},{"location":"4_interactions/#getting-values","title":"Getting Values","text":""},{"location":"4_interactions/#object-ids","title":"Object IDs","text":"<p>The most basic getter functions in the <code>Simulation</code> class return the IDs of objects within the simulation. These are:</p> Function Return Value <code>get_vehicle_ids(vehicle_types)</code> All vehicle IDs, or those of specific type(s). <code>get_detector_ids(detector_types)</code> All detector IDs, or those of specific type(s) - 'multientryexit' or 'inductionloop'. <code>get_controller_ids(controller_types)</code> All controller IDs, or those of specific type(s) - 'VSLController' or 'RGController'. <code>get_event_ids(event_statuses)</code> All event IDs, or those of specific status(es) - 'scheduled', 'active' or 'completed'. <code>get_geometry_ids(geometry_types)</code> All controller IDs, or those of specific type(s) - 'edge' or 'lane'. <code>get_tracked_edge_ids()</code> All tracked edge IDs. <code>get_junction_ids()</code> All junction IDs. <code>get_tracked_junction_ids()</code> All tracked junction IDs."},{"location":"4_interactions/#other-data","title":"Other Data","text":"<p>All data collected throughout the simulation is stored in the <code>sim_data</code> dictionary, however, its data (and other dynamic vehicle data) can be fetched using the <code>Simulation.get_[x]()</code> functions below.</p> <ul> <li><code>get_no_vehicles()</code>:<ul> <li>Returns the number of vehicles in the last step of the simulation.</li> </ul> </li> <li><code>get_tts()</code>:<ul> <li>Returns the Total Time Spent (TTS) by vehicles in the simulation during the last step.</li> </ul> </li> <li><code>get_delay()</code>:<ul> <li>Returns total vehicle delay during the last simulation step (calculated as the number of vehicles where speed &lt; 0.1m/s<sup>2</sup>, multiplied by the simulation step length).</li> </ul> </li> <li><code>get_vehicle_data(vehicle_ids)</code>:<ul> <li>Returns a dictionary containing all information on a vehicle. This is; 'type', 'longitude', 'latitude', 'altitude', 'heading', 'speed', 'acceleration', 'stopped', 'length', 'departure', 'destination' and 'origin'.</li> <li>TUD-SUMO stores static information (route origin, vehicle length etc.) to avoid unnecessary repeated calls to TraCI. This is automatically done when calling <code>get_vehicle_data()</code> on a vehicle for the first time.</li> <li><code>vehicle_ids</code> can be a single vehicle ID (string), or a list of IDs (list/tuple). If multiple IDs are given, a dictionary is returned with each vehicle's data stored under its ID.</li> </ul> </li> <li><code>get_all_vehicle_data(vehicle_types, all_dynamic_data):</code><ul> <li>Returns the total number of vehicles in the simulation, the total number of waiting vehicles, and if <code>all_dynamic_data == True</code>, the static &amp; dynamic data for all vehicles.</li> <li>If <code>all_dynamic_data == False</code>, an empty dictionary is returned as the last variable.</li> </ul> </li> <li><code>get_last_step_detector_vehicles(detector_ids, vehicle_types, flatten)</code>:<ul> <li>Returns the IDs of all vehicles who passed over the specified detector(s) in the last simulation step.</li> <li><code>detector_ids</code> and <code>vehicle_types</code> can either be a single value (string) or list of values (list/tuple). If multiple detector IDs are given, IDs for all detectors can either be returned in a single list (<code>flatten = True</code>), or the IDs can be returned in a dictionary with lists of IDs separated by detector (<code>flatten = False</code>).</li> </ul> </li> <li><code>get_last_step_geometry_vehicles(geometry_ids, vehicle_types, flatten)</code>:<ul> <li>Returns the IDs of all vehicles on the specified geometry in the last simulation step.</li> <li><code>geometry_ids</code> and <code>vehicle_types</code> can either be a single value (string) or list of values (list/tuple). If multiple geometry IDs are given, IDs for all geometries can either be returned in a single list (<code>flatten = True</code>), or the IDs can be returned in a dictionary with lists of IDs separated by geometry (<code>flatten = False</code>).</li> </ul> </li> <li><code>get_interval_detector_data(detector_id, n_steps, data_keys, avg_vals)</code>:<ul> <li>Returns data collected by a detector between during the time range (<code>curr_step - n_steps</code>, <code>curr_step</code>).</li> <li><code>data_keys</code> can either be a single value (string) or a list of values (list/tuple). The valid keys are 'vehicle_counts', 'speeds' and 'occupancies', although 'occupancies' is only valid for induction loop detectors.</li> <li>If <code>avg_vals == True</code>, then values are returned averaged, otherwise, raw values are returned.</li> </ul> </li> </ul> <p>To query routes and paths in the network, use the functions below.</p> <ul> <li><code>is_valid_path(edge_ids)</code>:<ul> <li>Tests whether a list of edges is a valid path. This is determined by checking whether each edge connects to the subsequent edge in the list.</li> <li>Valid paths can be added as a route using the <code>Simulation.add_route()</code> function.</li> </ul> </li> <li><code>get_path_travel_time(edge_ids, curr_tt, unit)</code>:<ul> <li>Calculate the travel time of a path (list of edges). If <code>curr_tt</code> is true, the travel time is calculated using current mean speed on edges. If <code>curr_tt</code> is false, the travel time is calculated using free-flow speed.</li> </ul> </li> <li><code>get_path_edges(origin, destination, curr_optimal)</code>:<ul> <li>Uses the A* algorithm to find the optimal route between two edges (<code>origin</code> to <code>destination</code>).</li> <li>If <code>curr_optimal</code> is true, the route is based on current conditions, using current mean speed on edges to find travel time. If <code>curr_optimal</code> is false, the route is calculated based on free-flow travel time.</li> </ul> </li> </ul>"},{"location":"4_interactions/#advanced-getters","title":"Advanced Getters","text":"<p>Vehicles, detectors and geometries all use a <code>Simulation.get_[x]_vals()</code> function, which allow you to very easily get a set of values for multiple objects. All 3 use the same structure, with the same type of parameters:</p> <ol> <li><code>vehicle_ids</code>/<code>detector_ids</code>/<code>geometry_ids</code>: A single ID (string) or list of IDs (list/tuple)</li> <li><code>data_keys</code>: A single data key (string) or list of data keys (list/tuple)</li> </ol> <p>If one data key is given, the raw value is returned, otherwise, a dictionary is returned containing the values separated by data key. Similarly, if one object ID is given, the raw data value/dictionary is returned, otherwise, a dictionary is returned containing the data separated by vehicle ID. For example:</p> <pre><code>&gt;&gt;&gt; my_sim.get_vehicle_vals(\"vehicle_1\", \"speed\")\n25\n\n&gt;&gt;&gt;  my_sim.get_vehicle_vals(\"vehicle_1\", (\"speed\", \"acceleration\"))\n{\"speed\": 25, \"acceleration\": -1}\n\n&gt;&gt;&gt;  my_sim.get_vehicle_vals((\"vehicle_1\", \"vehicle_2\"), \"speed\")\n{\"vehicle_1\": 25, \"vehicle_2\": 30}\n\n&gt;&gt;&gt;  my_sim.get_vehicle_vals((\"vehicle_1\", \"vehicle_2\"), (\"speed\", \"acceleration\"))\n{\"vehicle_1\": {\"speed\": 25, \"acceleration\": -1}, \"vehicle_2\": {\"speed\": 30, \"acceleration\": 2}}\n</code></pre> <p>Subscriptions and static vehicle data are used whenever possible to reduce TraCI calls. The valid data keys for each function are listed below.</p> <ul> <li><code>get_vehicle_vals()</code>:<ul> <li>'type': Vehicle type</li> <li>'length': Vehicle length</li> <li>'speed': Current vehicle speed</li> <li>'is_stopped': Bool denoting whether the vehicle is stopped</li> <li>'max_speed': Vehicle maximum speed</li> <li>'acceleration': Current vehicle acceleration</li> <li>'position': Current vehicle coordinates</li> <li>'altitude': Current vehicle altitude</li> <li>'heading': Current vehicle heading</li> <li>'departure': Vehicle departure time</li> <li>'edge_id': Current vehicle's edge ID</li> <li>'lane_idx': Index of the vehicle's current lane</li> <li>'origin': Departure edge ID of the vehicle</li> <li>'destination': Current destination edge ID of the vehicle</li> <li>'route_id': Current vehicle route ID</li> <li>'route_idx': The index of the vehicle's edge on its route</li> <li>'route_edges': The list of edges that the vehicle's route consists of</li> </ul> </li> <li><code>get_detector_vals()</code>:<ul> <li>'type': Detector type ('mutlientryexit' or 'inductionloop')</li> <li>'position': Detector coordinates</li> <li>'vehicle_count': Number of vehicles that passed over the detector in the last step</li> <li>'vehicle_ids': IDs of vehicles that passed over the detector in the last step</li> <li>'lsm_speed': Average speed of vehicles that passed over the detector in the last step</li> <li>'halting_no': Number of halting vehicles in the detector area (multi-entry-exit only)</li> <li>'lsm_occupancy': Average occupancy during the last step (induction loop only)</li> <li>'last_detection': Time since last detection (induction loop only)</li> </ul> </li> <li><code>get_geometry_vals()</code>:<ul> <li>'vehicle_count': Number of vehicles on the edge/lane</li> <li>'vehicle_ids': IDs of vehicles on the edge/lane</li> <li>'vehicle_speed': Average speed of vehicles on the edge/lane</li> <li>'halting_no': Number of halting vehicles on the edge/lane</li> <li>'vehicle_occupancy': Vehicle occupancy of edge/lane</li> <li>'curr_travel_time': Estimated travel time (calculated using length and average speed)</li> <li>'ff_travel_time': Estimated free-flow travel time (calculated using length and maximum speed)</li> <li>'emissions': CO, CO<sub>2</sub>, HC, PMx and NOx emissions, stored in a dictionary</li> <li>'length': Length of the edge/lane</li> <li>'max_speed': Maxmimum speed (edge max_speed is the average of its lanes)</li> <li>'connected_edges': Dictionary containing 'incoming' and 'outgoing' edges (edge only)</li> <li>'incoming_edges': Incoming edges (edge only)</li> <li>'outgoing_edges': Outgoing edges (edge only)</li> <li>'street_name': Street name, defined in SUMO (edge only)</li> <li>'n_lanes': Number of lanes in the edge (edge only)</li> <li>'lane_ids': IDs of all lanes in the egde (edge only)</li> <li>'edge_id': Edge ID for the lane (lane only)</li> <li>'n_links': Number of linked lanes (lane only)</li> <li>'allowed': List containing allowed vehicle types (lane only)</li> <li>'disallowed': List containing all prohibited vehicle types (lane only)</li> <li>'left_lc': Bool denoting whether left lane changes are allowed (lane only)</li> <li>'right_lc': Bool denoting whether right lane changes are allowed (lane only)</li> </ul> </li> </ul>"},{"location":"4_interactions/#setting-values","title":"Setting Values","text":"<p>Both vehicle and geometries (edges/lanes) also allow for dynamically setting variables with the <code>Simulation.set_vehicle_vals()</code> and <code>Simulation.set_geometry_vals()</code> functions. Both use the same types of parameters:</p> <ol> <li><code>vehicle_ids</code>/<code>geometry_ids</code>: A single ID (string) or list of IDs (list/tuple). If multiple IDs are given, the values are set for all objects.</li> <li><code>data_keys</code>: Unlike the <code>get_[x]_vals()</code> functions, data_keys are used as arguments. There is no limit on the number of data keys given.</li> </ol> <p>For example:</p> <pre><code>&gt;&gt;&gt; my_sim.set_geometry_vals(\"edge_1\", max_speed=40)\n&gt;&gt;&gt; my_sim.set_vehicle_vals((\"vehicle_1\", \"vehicle_2\"), max_speed=20, highlight=\"#FF0000\")\n</code></pre> <p>The valid data keys and their accepted data type are listed below. Note that the keys aim to be the same as those in the <code>get_[x]_vals()</code> functions (whenever possible).</p> <ul> <li><code>set_vehicle_vals()</code>:<ul> <li><code>colour</code>: Changes the vehicle's colour (either valid hex code or list of rgb(a) values)</li> <li><code>highlight</code>: Sets vehicle highlighting (boolean)</li> <li><code>speed</code>: Sets a new speed value for the vehicle (integer or float)</li> <li><code>max_speed</code>: Sets a new maximum speed for the vehicle (integer or float)</li> <li><code>acceleration</code>: Sets a new acceleration for a given duration (list/tuple containing speed value and duration)</li> <li><code>lane_idx</code>: Sets a vehicle to try and change lane index for a given duration (list/tuple containing lane index and duration)</li> <li><code>destination</code>: Sets a new destination by edge ID (string)</li> <li><code>route_id</code>: Sets the vehicle to another route by its ID (string)</li> <li><code>route_edges</code>: Sets the vehicle to a new route by edge IDs (list of strings)</li> <li><code>speed_safety_checks</code>: Indefinitely sets whether speed/acceleration safety constraints are followed when setting speed - can be boolean to turn on/off all checks or bitset (boolean/int)</li> <li><code>lc_safety_checks</code>: Indefinitely sets whether lane changing safety constraints are followed when changing lane - can be boolean to turn on/off all checks or bitset (boolean/int)</li> </ul> </li> <li><code>set_geometry_vals()</code>:<ul> <li><code>max_speed</code>: Set a new maximum speed/speed limit (lane or for all contained lanes) (integer or float)</li> <li><code>allowed</code>: Set a new list of allowed vehicle types, with an empty list allowing all (list of strings) (lane only)</li> <li><code>disallowed</code>: Set a new list of prohibited vehicle types (list of strings) (lane only)</li> <li><code>left_lc</code>: Sets the list of vehicle types that are allowed to change to the left lane (list of strings) (lane only)</li> <li><code>right_lc</code>: Sets the list of vehicle types that are allowed to change to the right lane (list of strings) (lane only)</li> </ul> </li> </ul>"},{"location":"4_interactions/#subscriptions","title":"Subscriptions","text":"<p>Subscriptions are a useful tool in TraCI that aim to reduce runtime by limiting the amount of API calls. This can be particularly effective when data needs to be collected at each simulation step. TUD-SUMO automatically adds vehicle subscriptions for basic variables including position, speed and acceleration as these are already used within the automatic data collection and are necessary for calculating vehicle delay at each step. Tracked edges will also automatically subcribe to vehicle IDs, as this is needed to collect step vehicle data.</p> <p>It is possible to disable automatic vehicle subscriptions by setting <code>automatic_subscriptions = False</code> in <code>Simulation.start()</code>. However, this is most likely unncessary and not recommened, particularly for applications where a lot of data needs to be repeatedly collected from the simulation.</p> <p>Otherwise, depending on the use case, it may be necessary to subscribe/unsubscribe to other variables. This can be done using the functions below. These use the same structure as the <code>get_[x]_vals()</code> functions with two parameters:</p> <ol> <li><code>vehicle_ids</code>/<code>detector_ids</code>/<code>geometry_ids</code>: A single ID (string) or list of IDs (list/tuple). Note that individual objects have their own set of subscriptions.</li> <li><code>data_key</code>: A single data key (string) or list of data keys (list/tuple).</li> </ol> <p>The valid data keys for each object type and respective function are listed below. Note that individual objects have their own set of subscriptions, so if you would like to subscribe to collect all vehicles' edge ID at each step, you must call <code>add_vehicle_subscriptions()</code> for all vehicle IDs.</p> <ul> <li> <p><code>add_vehicle_subscriptions()</code>/<code>remove_vehicle_subscriptions()</code>:</p> <ul> <li>'speed'</li> <li>'is_stopped'</li> <li>'max_speed'</li> <li>'acceleration'</li> <li>'position'</li> <li>'altitude'</li> <li>'heading'</li> <li>'edge_id'</li> <li>'lane_idx'</li> <li>'route_id'</li> <li>'route_idx'</li> </ul> </li> <li> <p><code>add_detector_subscriptions()</code>/<code>remove_detector_subscriptions()</code>:</p> <ul> <li>'vehicle_count'</li> <li>'vehicle_ids'</li> <li>'lsm_speed'</li> <li>'halting_no'</li> <li>'lsm_speed'</li> <li>'last_detection'</li> </ul> </li> <li> <p><code>add_geometry_subscriptions()</code>/<code>remove_geometry_subscriptions()</code>:</p> <ul> <li>'vehicle_count'</li> <li>'vehicle_ids'</li> <li>'vehicle_speed'</li> <li>'halting_no'</li> <li>'occupancy'</li> </ul> </li> </ul>"},{"location":"4_interactions/#addingremoving-vehicles","title":"Adding/removing Vehicles","text":"<p>Vehicles can be added to or removed from the simulation using the <code>Simulation.add_vehicle()</code> and <code>Simulation.remove_vehicles()</code> functions respectively. These functions and their parameters are detailed below.</p> <ul> <li><code>add_vehicle()</code>:<ul> <li><code>vehicle_id</code>: (Unique) ID for the new vehicle.</li> <li><code>vehicle_type</code>: Vehicle type.</li> <li><code>routing</code>: Denotes how the vehicle will route through the network (either route ID or (2x1) list of edge IDs for an OD pair).</li> <li><code>initial_speed</code>: Initial speed of the vehicle at insertion, defaults to maximum (either 'max', 'random' or a number &gt; 0).</li> <li><code>origin_lane</code>: Lane for insertion at origin, defaults to best (either 'random', 'free', 'allowed', 'best', 'first' or lane index).</li> </ul> </li> <li><code>remove_vehicles()</code>:<ul> <li><code>vehicle_ids</code>: A single vehicle ID (string) or list of IDs (list/tuple).</li> </ul> </li> </ul> <p>When repeatedly adding new vehicles, it may be useful to create a new route that vehicles can be assigned to. This can be done using <code>Simulation.add_route()</code>, which is detailed below.</p> <ul> <li><code>add_route()</code>:<ul> <li><code>routing</code>: List of edge IDs. If 2 disconnected edges are given, vehicles calculate an optimal path at insertion.</li> <li><code>route_id</code>: (Unique) route ID. If this is not given, the ID is generated using the origin and destination edge IDs.</li> <li><code>assert_new_id</code>: If true, an error is thrown for duplicate route IDs.</li> </ul> </li> </ul>"},{"location":"4_interactions/#custom-vehicle-functions","title":"Custom Vehicle Functions","text":"<p><code>Simulation.add_vehicle_in_funcs()</code> and <code>Simulation.add_vehicle_out_funcs()</code> can be used to easily add custom functions that are called with each vehicle that enters or leaves the simulation. An example of this is shown below. Multiple functions can be added and are called in the order in which they are added.</p> <pre><code>def new_vehicle_1(vehicle_id, origin):\n    print(vehicle_id, \"entered simulation from edge\", origin)\n\ndef new_vehicle_2(curr_step):\n    print(\"new vehicle at step\", curr_step, \"\\n\")\n\ndef exiting_vehicle(vehicle_id, curr_step):\n    print(vehicle_id, \"left simulation at step\", curr_step)\n\nmy_sim.add_vehicle_in_funcs([new_vehicle_1, new_vehicle_2])\nmy_sim.add_vehicle_out_funcs(exiting_vehicle)\n\nwhile my_sim.is_running():\n    my_sim.step_through()\n</code></pre> <p>Running this example would therefore produce:</p> <pre><code>&gt;&gt;&gt; run_sim.py\ncar_1 entered simulation from edge west_1\nnew vehicle at step 0\n\ncar_2 entered simulation from edge west_1\nnew vehicle at step 0\n\ncar_1 left simulation at step 10\ncar_2 left simulation at step 10\n</code></pre> <p>Only specific parameters (<code>curr_step</code>, <code>vehicle_id</code>, <code>route_id</code>, <code>vehicle_type</code>, <code>departure</code>, <code>origin</code>, <code>destination</code>) can be used, although <code>add_vehicle_out_funcs()</code> only takes functions that use <code>curr_step</code> and/or <code>vehicle_id</code>.</p> <p>These functions can be removed using <code>Simulation.remove_vehicle_in_funcs()</code> and <code>Simulation.remove_vehicle_out_funcs()</code>.</p>"},{"location":"5_tracked_objs/","title":"Tracked Objects","text":"<p>Tracked objects are a useful way to include extra objects in the automatic data collection. Whilst all data from every detector is automatically included, specific scenarios may contain a large number of edges or junctions. Therefore, important edges or junctions can be tracked to automatically collect more specific information, such as inflow or average speeds. Tracked objects are also supported within the plotter class, so that phase signal diagrams or space-time diagrams can easily be plotted with significantly less effort.</p> <p>Currently, only edges and junctions can be tracked, although this may change in the future.</p>"},{"location":"5_tracked_objs/#tracked-junctions","title":"Tracked Junctions","text":"<p>There are two types of tracked junctions; regular junctions and metered junctions. Most intersections will only need to be tracked as a regular junction, whilst metered junctions are a subclass of junction that include some extra tracking for motorway on-ramp metering.</p> <p>Tip</p> <p>Note that traffic light/ramp meter control itself is not discussed here. An adaptive traffic signal or ramp meter does not have to be tracked and not all tracked junctions require some control. Tracking a junction with an adaptive traffic signal or ramp meter simply adds a level of data collection, however, it is recommended and makes evaluation of the controllers much easier.</p> <p>All parameters to create a tracked junction are given as a dictionary and is done using the <code>Simulation.add_tracked_junctions()</code> function. This can be in code, or from a '.json' or '.pkl' file. Tracked junctions can also be included in the object parameters file when calling <code>Simulation.load_objects()</code>, under 'junctions'. A tracked junction can be initialised at 3 different levels, depending on the amount of data collection required.</p> <ol> <li> <p>Signal tracking only:</p> <ul> <li>This is the lowest level of tracking, where only signal phases and average green/red times are tracked. Therefore, this level is only useful when the specified junction has a traffic light.</li> <li>In this case, the only required parameters are the junction ID or a list of junction IDs. It is recommended to give junctions and their traffic lights the same ID in SUMO in order to avoid confusion.</li> </ul> </li> <li> <p>Inflow/outflow tracking:</p> <ul> <li>Traffic-flow related variables can be tracked by tracked junctions, however, it is necessary to define the detectors used to do so.</li> <li>Here, the input for <code>Simulation.add_tracked_junctions()</code> is a dictionary, where each junction has a 'flow_params' value. This is a dictionary containing 'inflow_detectors', 'outflow_detectors' and 'vehicle_types'. 'inflow_detectors' and 'outflow_detectors' are lists containing the detectors that will be used to register vehicles entering and exiting the junction, whilst 'vehicle_types' is an optional parameter that lists the vehicle types that should be registered (defaults to all).</li> </ul> </li> <li> <p>Metered junctions:</p> <ul> <li>Metered junctions adds options for tracking queuing variables; queue length, queue delay and spillback. This is primarily designed for use in ramp metering systems.</li> <li>Here, the input for <code>Simulation.add_tracked_junctions()</code> is a dictionary, where each junction has a 'meter_params' value. This is a dictionary containing 'min_rate', 'max_rate', 'init_rate', 'queue_detector' and 'ramp_edges'. These are detailed below, however, flow can still be tracked as above.</li> <li>'min_rate' is a required parameter denoting the minimum allowed metering rate.</li> <li>'max_rate' is a required parameter denoting the maximum allowed metering rate.</li> <li>'init_rate' denotes the initial metering rate set after initialisation.</li> <li>'queue_detector' is the ID of a multi-entry-exit detector that should be placed on the on-ramp. The entry detector should be placed at the start of the on-ramp, and the exit detector just before the traffic light. If given, queue length and delay at each step is tracked automatically.</li> <li>If you would like to track vehicle spillback, provide the list of edge IDs that make up the ramp under the 'ramp_edges' parameter. This can also be used instead of 'queue_detector' to track queue length and delay, however, this approach is much slower. Tracking spillback in this way will only work when vehicles are inserted directly onto the on-ramp (ie. no urban roads connect to the on-ramp), and requires checking all unloaded vehicles of their insertion edge which can be slow.</li> </ul> </li> </ol> <p>Examples of these different levels are shown below.</p> <pre><code># Level 1: Only signal phases &amp; green/red times are tracked\nmy_sim.add_tracked_junctions([\"traffic_signal_1\", \"traffic_signal_2\"])\n\n# Level 2: Track inflow/outflow (&amp; signal phases &amp; green/red times)\nmy_sim.add_tracked_junctions({\"traffic_signal_3\":\n                                {\"flow_params\":\n                                    {\"inflow_detectors\":  [\"det_in_1\", \"det_in_2\"],\n                                     \"outflow_detectors\": [\"det_out_1\", \"det_out_2\"],\n                                     \"vehicle_types\": [\"cars\", \"lorries\", \"motorcycles\", \"vans\"]}\n                                }\n                            })\n\n# Level 3: Track metering (&amp; inflow/outflow &amp; signal phases &amp; green/red times)\nmy_sim.add_tracked_junctions({\"ramp_meter\":\n                                {\"meter_params\":\n                                    {\"min_rate\": 200,\n                                    \"max_rate\": 2000,\n                                    \"queue_detector\": \"ramp_queue\"},\n                                \"flow_params\":\n                                    {\"inflow_detectors\": [\"ramp_inflow\", \"ramp_upstream\"],\n                                    \"outflow_detectors\": [\"ramp_downstream\"]}\n                                }\n                            })\n</code></pre> <p>All data from tracked junctions is stored in the <code>sim_data</code> dictionary under 'data/junctions/{junction_id}'. This will contain the junction's 'position', 'init_time' and 'curr_time' (referring to the start and ent time of the data collection). Phase data is then stored under 'tl', whilst flow and metering data are under 'flow' and 'meter' respectively.</p> <p>Data collection for tracked junctions can be reset using the function below, however, data collection is also reset when using <code>Simulation.reset_data()</code>.</p> <pre><code>my_sim.tracked_junctions[\"traffic_signal_1\"].reset()\n</code></pre>"},{"location":"5_tracked_objs/#tracked-edges","title":"Tracked Edges","text":"<p>Tracked edges are very simple to initialise, but include a lot of useful data collection. Edges are tracked using only their ID with the <code>Simulation.add_tracked_edges()</code> function.</p> <pre><code># Add all edges as a tracked edge\nmy_sim.add_tracked_edges()\n\n# Add a list of edges as tracked edges\nmy_sim.add_tracked_edges([\"edge_1\", \"edge_2\", \"edge_3\", \"edge_4\", \"edge_5\"])\n</code></pre> <p>All data from tracked edges is stored in the <code>sim_data</code> dictionary under 'data/edges/{edge_id}'. The main data collected is under 'data/edges/{edge_id}/step_vehicles'. This includes the vehicle ID, position, speed and lane index for all vehicles on the edge at each step. This precise data is used to plot trajectories and space-time diagrams.</p> <p>The step vehicle data is stored in a (4x1) array as follows:</p> <ol> <li>Vehicle ID</li> <li>Vehicle position measured as [0 - 1], denoting percent travelled along the edge</li> <li>Vehicle speed in <code>Simulation</code> class units</li> <li>Lane index [0 - no. lanes]</li> </ol> <p>Tracked edges collect average speed, flow and density at each time step and store these values in a list. Funamental diagrams can be plotted with <code>TrackedEdge</code> data using the <code>Plotter.plot_fundamental_diagram()</code> function, but it is possible to return the individual values. This data is stored in the <code>sim_data</code> dictionary under 'data/edges/{edge_id}/speeds', 'data/edges/{edge_id}/flows' and 'data/edges/{edge_id}/densities', but can be fetched from the <code>TrackedEdge</code> object as below. A value of -1 denotes that there were no vehicles on the edge during the step.</p> <pre><code>speeds    = my_sim.tracked_edges[\"edge_1\"].speeds\nflows     = my_sim.tracked_edges[\"edge_1\"].flows\ndensities = my_sim.tracked_edges[\"edge_1\"].densities\n</code></pre> <p>'linestring', 'length', 'to_node', 'from_node', 'n_lanes', 'init_time' and 'curr_time' are also stored for each edge.</p> <p>Data collection for specific tracked edges can be reset using the function below, however, data collection is also reset when using <code>Simulation.reset_data()</code>.</p> <pre><code>my_sim.tracked_edges[\"edge_1\"].reset()\n</code></pre>"},{"location":"6_traffic_control/","title":"Traffic Control","text":""},{"location":"6_traffic_control/#traffic-signal-control","title":"Traffic Signal Control","text":"<p>Tip</p> <p>No initialisation is needed to perform dynamic traffic signal control, however, it is recommeded to create a tracked junction to automatically collect data from the junction.</p> <p>By default, all traffic signals will use the phases set in SUMO/netedit at the beginning of the simulation. TUD-SUMO is able to override these settings and update phases automatically, which is done using a <code>phase_dict</code> as shown below. A <code>phase_dict</code> can be included in the parameters file under 'phases' when calling <code>Simulation.load_objects()</code>.</p> <pre><code>phase_dict = {\"traffic_signal_1\":\n                 {\"phases\": [\"GGrr\", \"yyrr\", \"rrGG\", \"--yy\"],\n                  \"times\": [27, 3, 17, 3]\n                 },\n              \"traffic_signal_2\":\n                 {\"phases\": [\"GGrr\", \"yyrr\", \"rrGG\", \"--yy\"],\n                  \"times\": [20, 3, 34, 3]\n                 }\n             }\n</code></pre> <p>This dictionary uses two components:</p> <ol> <li>Phases:<ul> <li>This contains a list of phase strings, which represent the signal status during each phase. The phase strings must be the same length as the number of movements in SUMO.</li> <li>Characters in the phase string can either 'r' (red), 'y' (yellow), 'g' (green with no priority), 'G' (green with priority) or '-' (do not change).</li> <li>The index of each character refers to the setting for the corresponding movement, which are numbered clockwise starting at north (right turns \u2192 straight \u2192 left turns), with pedestrian crossings at the end.</li> </ul> </li> <li>Times:<ul> <li>This contains the durations in seconds for each corresponding phase string.</li> <li>Phase durations cannot be less than the simulation step length.</li> </ul> </li> </ol> <p>Once this has been created, the phases can be set using the <code>Simulation.set_phases()</code> function. <code>start_phase</code> can be used to start at different points in the phase cycle. <code>overwrite</code> determines whether to completely overwrite the phase dictionary for all signals or simply for specified signals.</p> <pre><code>my_sim.set_phases(phase_dict, start_phase=0, overwrite=True)\n</code></pre> <p>Alternatively, it is possible to set a signal's phases indefinitely using <code>Simulation.set_tl_colour()</code>. The input can either be a regular phase string or a single character, meaning all movements are set this way. <code>Simulation.change_phase()</code> can be used to change to skip to a specific phase in the cycle.</p> <pre><code># Set \"traffic_signal_1\" permanently to all green\nmy_sim.set_tl_colour(\"traffic_signal_1\", \"G\")\n\n# Set \"traffic_signal_2\" permanently to \"rrGG\"\nmy_sim.set_tl_colour(\"traffic_signal_2\", \"rrGG\")\n\n# Skip \"traffic_signal_3\" to phase 3\nmy_sim.change_phase(\"traffic_signal_3\", 2)\n</code></pre>"},{"location":"6_traffic_control/#ramp-metering","title":"Ramp Metering","text":"<p>Ramp metering is a motorway control measure where a traffic light is placed at an on-ramp in order to limit flow and avoid congestion. This help an engineer fully exploit the capacity of a motorway section next to an on-ramp without exceeding it. It is also an important method of reducing the impact of capacity drop, where the measured outflow from a bottleneck is significantly lower than the expected outflow. The most commonly used ramp metering algorithm in practice is Asservissement Lin\u00e9aire d'entr\u00e9e Autoroutiere (ALINEA).</p> <p></p> <p>Tip</p> <p>No initialisation is needed to perform ramp metering, however, it is recommeded to create a tracked junction to automatically collect data from the meter.</p> <p>Like a regular traffic signal, ramp meters will follow the phases defined within SUMO/netedit by default. Otherwise, initialising the ramp meter as a tracked junction will allow you to set an initial metering rate, which will start at the next simulation step.</p> <pre><code>my_sim.add_tracked_junctions({\"ramp_meter\":\n                                {'meter_params':\n                                    {'min_rate': 200,  # Minimum allowed metering rate\n                                    'max_rate': 2000,  # Maximum allowed metering rate\n                                    'init_rate': 1800, # Initial metering rate\n                                    'queue_detector': \"ramp_queue\"},\n                                'flow_params':\n                                    {'inflow_detectors': [\"ramp_inflow\", \"ramp_upstream\"],\n                                    'outflow_detectors': [\"ramp_downstream\"]}\n                                }\n                            })\n</code></pre> <p>The ramp metering rate can then be set as below. Note that all metering rates are defined in vehicles/hour.</p> <pre><code>my_sim.set_tl_metering_rate(rm_id=\"ramp_meter\", metering_rate=1500)\n</code></pre> <p>Ramp meters use the exact same logic and <code>phase_dict</code> as traffic signals to operate, except the <code>Simulation.set_tl_metering_rate()</code> function calculates a phase setting that would result in the desired flow. This is primarily done by varying the red time. The settings can be changed using the parameters:</p> <ul> <li><code>g_time</code>: Green time, defaults to 1s for a one-car-per-green policy.</li> <li><code>y_time</code>: Yellow time, defaults to 1s.</li> <li><code>min_red</code>: Minimum red time. If the flow would require a red time less than this, the meter is set to green for the duration of the control interval.</li> <li><code>control_interval</code>: Control interval length in seconds (control interval % resulting cycle length = 0, ie. phases will loop seamlessly with each control interval).</li> </ul> <p>If the junction is tracked, all ramp metering data will be stored under 'data/junctions/{meter_id}/meter', and will contain 'metering_rates', 'rate_times', 'queue_lengths', 'queue_delays', 'min_rate' and 'max_rate'.</p> <p>Warning</p> <p>Note that as ramp meters use the same logic as adaptive traffic signals, it is possible to accidentally overwrite their settings when using <code>Simulation.set_phases()</code>.</p>"},{"location":"6_traffic_control/#variable-speed-limits","title":"Variable Speed Limits","text":"<p>Variable Speed Limits (VSL), also called dynamic speed limits, are a method of motorway traffic control where speed limits on road sections are dynamically changed based on conditions. A major advantage of this can be the increased safety, as VSL will often aim to lower and homogenise vehicle speeds, although it can also be used to limit congestion by 'holding back' vehicles and 'storing' them away from congested areas of a network. In practice, VSL is implemented through variable message signs on gantries above the motorway.</p> <p>VSL can be simulated using a <code>VSLController</code> object. These can be added with the <code>Simulation.add_controllers()</code> function with their parameters in a dictionary as below. Multiple VSL and Dynamic Route Guidance (RG) controllers can be created in the same parameter dictionary. This can also be included under 'controllers' when calling <code>Simulation.load_objects()</code>.</p> <pre><code>vsl_parameters = {\"vsl_controller\":\n                     {\"type\": \"VSL\",\n                      \"geometry_ids\": [\"edge_1\", \"edge_2\", \"edge_3\"],\n                      \"default_limit\": 80\n                     }\n                 }\nmy_sim.add_controllers(vsl_parameters)\n</code></pre> <p>Both 'type' and 'geometry_ids' are the only required parameters. 'type' should be set to 'VSL' to create a VSL controller, whilst 'geometry_ids' is a list containing the IDs of edges under control. Note that controlled geometries can be either edges or lanes. 'default_limit' is an optional parameter denoting the default speed limit.</p> <p>A VSL controller can also be created by directly initialising the object with the same parameters dictionary, however, it must be added to the simulation to operate.</p> <pre><code>from tud_sumo.controllers import VSLController\n\nvsl_controller = VSLController(vsl_id=\"vsl_controller\", vsl_params=vsl_parameters, simulation=my_sim)\nmy_sim.add_controllers({\"vsl_controller\": vsl_controller})\n</code></pre> <p>The controller will initialise as deactivated, meaning the controlled edges/lanes will use their default speed limits/maximum speed as defined in SUMO/netedit. However, it can be activated using the <code>VSLController.set_speed_limit()</code> function as below. This can either be used to activate the VSL with a new speed limit value, or to activate the VSL with the previously used speed limit or default value. Note that the same speed limit is set for all controlled edges/lanes.</p> <p>The VSL controller can then be deactivated using the <code>VSLController.deactivate()</code> function. This will set all edges/lanes to their original speed limit as defined in SUMO/netedit.</p> <pre><code># Activate controller, setting speed limit to 60kmph\nmy_sim.controllers[\"vsl_controller\"].set_speed_limit(60)\n\n# Deactivate the control, set speed limits to no-control values\nmy_sim.controllers[\"vsl_controller\"].deactivate()\n\n# Reactivate controller, setting speed limit to last used value (60kmph)\nmy_sim.controllers[\"vsl_controller\"].set_speed_limit()\n</code></pre> <pre><code>&gt;&gt;&gt; my_sim.controllers[\"vsl_controller\"].activated\nTrue\n</code></pre> <p>VSL controllers will automatically register and save the changes in speed limit, and the times at which they occur. This data is stored in the <code>sim_data</code> dictionary under 'data/controllers/{vsl_id}/activation_times'. This stores a series of tuples where the first value is the speed limit setting and the second value is the time step this setting was made. Speed limits of -1 denote the controller is being deactivated. Otherwise, the average speed on controlled edges/lanes throughout the simulation is also collected under 'data/controllers/{vsl_id}/geometry_data/{geometry_id}/avg_speeds'.</p> <p>VSL controller data can be reset using <code>VSLController.reset()</code>, or the controller itself can be removed using <code>Simulation.remove_controllers()</code>.</p>"},{"location":"6_traffic_control/#dynamic-route-guidance","title":"Dynamic Route Guidance","text":"<p>Dynamic Route Guidance (RG) is a method of traffic management where vehicles are rerouted in order to avoid exceeding capacity on certain roads. This can be particularly useful in cases of non-recurrent congestion, such as during an accident, as drivers can be advised to avoid affected roads and given guidance on alternative routes. In practice, this is typically implemented for motorway traffic management with variable message signs above the road, although information can be transmitted directly to drivers with Vehicle-to-Infrastructure (V2I) technology.</p> <p></p> <p>RG can be simulated using a <code>VSLController</code> object. These can be added with the <code>Simulation.add_controllers()</code> function with their parameters in a dictionary as below. Multiple RG and Variable Speed Limit (VSL) controllers can be created in the same parameter dictionary. This can also be included under 'controllers' when calling <code>Simulation.load_objects()</code>.</p> <pre><code>rg_parameters = {\"rg_controller\":\n                    {\"type\": \"RG\",\n                     \"detector_ids\": [\"induction_loop_1\"],\n                     \"old_destination\": \"off_ramp_1\",\n                     \"new_destination\": \"off_ramp_2\",\n                     \"diversion_pct\": 0.5,\n                     \"vehicle_type\": [\"cars\", \"lorries\", \"motorcycles\", \"vans\"],\n                     \"highlight\": \"00FF00\"\n                    }\n                }\nmy_sim.add_controllers(rg_parameters)\n</code></pre> <p>The only required parameters are 'type' and 'detector_ids'. 'type' should be set to 'RG' to create a RG controller, whilst 'detector_ids' is a list containing the IDs of induction loop detectors that will act as the point where vehicles are redirected. All other parameters are optional and are detailed below.</p> <ul> <li>'old_destination': Edge ID. If given, only vehicles with this as their destination will be redirected.</li> <li>'new_destination': Edge ID. If given, this is used as the default new destination for redirected vehicles.</li> <li>'diversion_pct': Float [0-1]. This acts as a probability of redirection for vehicles to simulate compliance. The default is 100%.</li> <li>'vehicle_type': List of vehicle types for redirected vehicles.</li> <li>'highlight': Hex code or list of rgba values. If given, redirected values are recoloured.</li> </ul> <p>A RG controller can also be created by directly initialising the object with the same parameters dictionary, however, it must be added to the simulation to operate.</p> <pre><code>from tud_sumo.controllers import RGController\n\nrg_controller = RGController(vsl_id=\"rg_controller\", rg_params=rg_parameters, simulation=my_sim)\nmy_sim.add_controllers({\"rg_controller\": rg_controller})\n</code></pre> <p>The controller will initialise as deactivated, meaning no vehicles are redirected, however, it can be activated using the <code>RGController.activate()</code> function. Similarly to VSL controllers, this can either be used to activate the RG with a new redirection target or 'new_destination', or to activate the RG with the previously used target or default value. The diversion percent or highlight can also be changed.</p> <pre><code># Activate controller &amp; redirect vehicles to 'off_ramp_2'\nmy_sim.controllers[\"vsl_controller\"].activate(\"off_ramp_2\")\n\n# Deactivate the control &amp; stop redirecting vehicles\nmy_sim.controllers[\"vsl_controller\"].deactivate()\n\n# Reactivate controller &amp; redirect vehicles to 'off_ramp_3\nmy_sim.controllers[\"vsl_controller\"].activate(\"off_ramp_3\")\n</code></pre> <pre><code>&gt;&gt;&gt; my_sim.controllers[\"rg_controller\"].activated\nTrue\n</code></pre> <p>RG controllers will automatically register and save changes, and the times at which they occur. This data is stored in the <code>sim_data</code> dictionary under 'data/controllers/{rg_id}/activation_times'.</p> <p>This stores a series of tuples where the first value is the new destination that vehicles are redirected towards, the second value is the diversion percent and the third is the time this change was made. A destination and diversion percent value of -1 denote the controller is being deactivated. Otherwise, the number of vehicles redirected throughout the simulation is also collected under 'data/controllers/{rg_id}/n_diverted'.</p> <p>New route objects can be created using <code>Simulation.add_route()</code>. Vehicles can then be redirected using the ID for the new route.</p> <p>VSL controller data can be reset using <code>VSLController.reset()</code>, or the controller itself can be removed using <code>Simulation.remove_controllers()</code>.</p>"},{"location":"7_events/","title":"Events","text":"<p>Events can be a useful part of designing a scenario, and can be used to simulate incidents, incident responses, or even different types of fixed control. TUD-SUMO includes the logic to schedule events and undo the changes made, for example, events can be used to reduce the speed limit of a road between specific times. Events designed to simulate incidents can also be created dynamically, with control over where the incident occurs and for how long. Events are also integrated into the plotting functions of TUD-SUMO, and can be displayed automatically on graphs if desired.</p> <p></p>"},{"location":"7_events/#scheduled-events","title":"Scheduled Events","text":"<p>Scheduled events are initialised through a event parameters dictionary, and added to the simulation through the <code>Simulation.add_events()</code> function as below. This dictionary can either be in code or as a '.json' or '.pkl' file, and can be included in the object parameters dictionary under 'events' when calling <code>Simulation.load_objects()</code>. These are shown below.</p> <p>All events require a 'start_time'/'start_step' and 'end_time'/'end_step' which represent when the event will occur, either in steps or simulation time. Otherwise, there are two types of effects that can be used; 'edges' or 'vehicles'.</p> <ol> <li>'edges':<ul> <li>Including edge effects will change edge states when the event is active. Both edges and lanes can be included.</li> <li>Any variable defined in the data keys for the <code>Simulation.set_edge_vals()</code> function can be used. The new edge/lane settings should be included under 'actions' in the edge effects dictionary. The edge/lane IDs should be included under 'edge_ids'.</li> <li>When an event is first scheduled, the base values for all edges/lanes are stored. When the event occurs, all changes defined in the parameters dictionary are made. Once the event is over, all changes are undone.</li> </ul> </li> <li>'vehicles':<ul> <li>Including vehicle effects will aim to change vehicle states whilst the effect is active, or changes can be made indefinitely.</li> <li>Any variable defined in the data keys for the <code>Simulation.set_vehicle_vals()</code> function can be used. The new vehicle settings should be included under 'actions' in the vehicle effects dictionary.</li> <li>Vehicles can either be affected based on a list of vehicle IDs or based on location If 'vehicle_ids', only the specified vehicles will be affected. If 'location' is given, affected vehicles are randomly chosen based on where they are in the network. The locations list can, therefore, include edge IDs, lane IDs or detector IDs, meaning that vehicles that pass over a specific edge/lane/detector can be controlled during an event. It is required to provide either a 'vehicle_ids' or 'location' list.</li> <li>If vehicles are being chosen randomly based on location, there are three other parameters that can be used; 'vehicle_limit', 'effect_probability' and 'effect_duration'. If a 'vehicle_limit' is given, new vehicles will no longer be effected once this threshold has been reached. If an 'effect_probability' is given, new vehicles will only be affected based on this probability. If 'effect_duration' is given, vehicles will only be affected for a certain amount of steps, otherwise, they are permanently affected.</li> <li>The 'highlight' parameter can be used to colour affected vehicles in the GUI.</li> <li>If 'remove_affected_vehicles' is given and when set to <code>True</code>, affected vehicles are removed from the simulation once the effect is over.</li> <li>Both 'speed_safety_checks' and 'lc_safety_checks' are boolean parameters that can be used to disable vehicle safety checks when changing lanes or speed. This may be useful when directing vehicles to make unsafe movements as these checks are enabled in SUMO by default.</li> </ul> </li> </ol> <p>Tip</p> <p>Both vehicle and edge/lane effects can be used during the same scheduled event.</p> <p>An example of a scheduled event with edge effects is shown below. Here, 'lane_1' and 'lane_2' are closed to all vehicles between 200-400s.</p> <pre><code>bn_parameters = {\"bottleneck\": \n                    {\"start_time\": 200,\n                     \"end_time\": 450,\n                     \"edges\":\n                         {\"edge_ids\": [\"lane_1\", \"lane_2\"]\n                          \"actions\":\n                              {\"disallowed\": [\"passenger\",\"trailer\",\"motorcycle\",\"delivery\"]},\n                         }\n                    }\n                }\n</code></pre> <p>Warning</p> <p>When suddenly closing edges or lanes like this, vehicles may get trapped until permissions are changed back. This is expected as closing lanes also closes outgoing connections from the lane, meaning that vehicles cannot leave.</p> <p>An example of a scheduled event with vehicle effects is shown below with a possible reaction to the bottleneck. Here, vehicles on nearby edges 'edge_1', 'edge_2' and 'edge_3' have their maximum speed changed to 40kmph for 100s, with 100% probability. These affected vehicles are coloured red.</p> <pre><code>rp_parameters = {\"bottleneck_reaction\":\n                    {\"start_time\": 210,\n                     \"end_time\": 500,\n                     \"vehicles\":\n                        {\"locations\": [\"edge_1\", \"edge_2\", \"edge_3\"],\n                         \"actions\": {\"max_speed\": 40}\n                         \"effect_duration\": 100,\n                         \"effect_probability\": 1,\n                         \"remove_vehicles\": False,\n                         \"speed_safety_checks\": False,\n                         \"lc_safety_checks\": False,\n                         \"highlight\": \"#FF0000\"\n                        }\n                    }\n                }\n</code></pre> <p>Event data is stored in the <code>sim_data</code> dictionary under 'data/events/{status}/{event_id}'. The status can either be 'scheduled', 'active' or 'completed'. Each contains a list of events and their event parameters.</p>"},{"location":"7_events/#dynamic-incidents","title":"Dynamic Incidents","text":"<p>Incidents on the network can be dynamically simulated using the <code>Simulation.cause_incident()</code> function. This creates an event that starts in the next simulation step, where a set of vehicles stop in the road for a set duration. After the incident, these vehicles are removed. Dynamically causing incidents may be useful when training or evaluating incident-responsive traffic management systems.</p> <p>The only required parameter is <code>duration</code>, denoting the duration of the incident in steps. Otherwise, the vehicles chosen can be either specified by the user or completely random. Below is an example of an incident lasting 100s that involves two specific vehicles, 'car_1', 'lorry_1'. By default, the edges that the vehicles are on have their speed limits reduced to 15kmph (or 10mph) to simulate vehicles driving cautiously around the incident. This can be disabled by setting <code>edge_speed</code> to <code>None</code>.</p> <pre><code>my_sim.cause_incident(duration=100, vehicle_ids=[\"car_1\", \"lorry_1\"])\n</code></pre> <p>For random incidents, it is still required to set the location through the <code>geometry_ids</code> parameter. This can be a list of edge/lane IDs or single ID. Vehicles in this location(s) are then randomly selected to be involved in the incident. <code>n_vehicles</code> denotes how many vehicles should be included. <code>vehicle_separation</code> is a float [0-1] that denotes how far apart the randomly selected vehicles should be, with 0 being close. Note that if there not enough vehicles on the selected edges, the surrounding edges are searched, meaning the incident may spread across many distant edges with high <code>vehicle_separation</code>. <code>highlight_vehicles</code> is a boolean that denotes whether to highlight involved vehicles with a circle around them.</p> <p>Warning</p> <p>With a high <code>n_vehicles</code> value, the algorithm may not be able to find enough vehicles, particularly with a high <code>vehicle_separation</code>. If <code>assert_n_vehicles</code> is set to <code>True</code>, an error will be thrown when this is the case, otherwise, the simulation will continue and <code>cause_incidents()</code> will return <code>False</code>.</p> <p>Below is an example of a dynamic incident. Here, 4 cars on edges 'edge_1' and 'edge_2' are stopped on the road for 100s, whilst the edges have their speed reduced to 20kmph. Each incident is added to the simulation as an event, meaning it will show in saved data and on plots as an event. By default, the incident will be defined a unique ID 'incident_[x]', however, an ID can be assigned manually as below.</p> <pre><code>success = my_sim.cause_incident(duration=100,\n                                geometry_ids=[\"edge_1\", \"edge_2\"],\n                                n_vehicles=4,\n                                vehicle_separation=0,\n                                assert_n_vehicles=False,\n                                edge_speed=20,\n                                highlight_vehicles=True,\n                                incident_id=\"pileup\"\n                               )\n</code></pre>"},{"location":"8_plotting/","title":"Plotting Data","text":"<p>TUD-SUMO aims to provide plotting functions with each feature. These are specifically tailored to the data collected in the <code>sim_data</code> and have a unified and standardised form. It has also been designed to facilitate plotting a large number of graphs, and graphs for different scenarios. All graphs for a specific simulation can, therefore, be saved with the same label and in specific locations.</p>"},{"location":"8_plotting/#plotter-class","title":"Plotter Class","text":"<p>The <code>Plotter</code> object is initialised with a corresponding active <code>Simulation</code> object or data file from previous runs. This is the only required parameter, although the other settings are:</p> <ul> <li><code>sim_label</code>: Adds a string as a label to the title of all plots.</li> <li><code>time_unit</code>: Sets the time scale used for all plots, either 'steps', 's' (seconds), 'm' (minutes) or 'hr' (hours).</li> <li><code>save_fig_loc</code>: Sets the location for all saved figures.</li> <li><code>save_fig_dpi</code>: Resolution for saved figures.</li> <li><code>overwrite_figs</code>: Denotes whether to overwrite old figures when saving.</li> </ul> <pre><code>from tud_sumo.plot import Plotter\n\n# Simple initialisation\nplt = Plotter(my_sim)\n\nplt = Plotter(simulation=\"example_data.json\",\n              sim_label=\"Example\",\n              time_unit=\"hr\",\n              save_fig_loc=\"figs/\",\n              save_fig_dpi=400,\n              overwrite_figs=False\n             )\n</code></pre>"},{"location":"8_plotting/#plotting-graphs","title":"Plotting Graphs","text":""},{"location":"8_plotting/#display-saving-graphs","title":"Display &amp; Saving Graphs","text":"<p>All graphs can be saved or shown onscreen with the <code>save_fig</code> parameter. If a valid filename is given, the resulting plot is saved, otherwise, it is shown onscreen. An example is shown below.</p> <pre><code># Display trajectories graph\nplt.plot_trajectories([\"edge_1\", \"edge_2\", \"edge_3\"])\n\n# Save trajectories graph to 'figs/trajectories.png'\nplt.plot_trajectories([\"edge_1\", \"edge_2\", \"edge_3\"], save_fig=\"figs/trajectories.png\")\n</code></pre>"},{"location":"8_plotting/#common-parameters","title":"Common Parameters","text":"<p>Whenever possible, all plotting functions include <code>time_range</code> and <code>show_events</code> parameters. By default, graphs are plotted for the data throughout the whole simulation. <code>time_range</code> can be used to plot a specific duration within the simulation, and is defined in in plotter time units, ie. hours or minutes. If <code>show_events</code> is set to true, graphs will display times with active events with a shaded region. Examples of these are shown below.</p> <p></p>"},{"location":"8_plotting/#colours","title":"Colours","text":"<p>Certain functions use a <code>plt_colour</code> parameter that can be used to set the line colour when plotting graphs. All matplotlib colours are valid parameters. By default, TUD-SUMO uses the TU Delft colour palette as below, and so these colours are also valid parameters.</p> <p></p>"},{"location":"8_plotting/#plotting-functions","title":"Plotting Functions","text":"<p>Warning</p> <p>Please note that some functions will require objects to be created or tracked.</p> <p>All (current) plotting functions are listed in the table below. Several graph examples are shown beneath the table.</p> Function Plot <code>plot_vehicle_data()</code> Network-wide vehicle data, either number of vehicles, number of waiting vehicles, Total Time Spent (TTS) or delay. <code>plot_detector_data()</code> Detector specific data, either speeds, vehicle counts or occupancies. <code>plot_junc_flows()</code> Either junction inflow &amp; outflow, or number of vehicles in an intersection. <code>plot_tl_colours()</code> Traffic light signal settings over time. <code>plot_od_demand()</code> Flow rate, either for a route or an OD pair. Note, this only includes data added in TUD-SUMO. <code>plot_od_trip_times()</code> Average trip times for OD pairs. <code>plot_trip_time_histogram()</code> Trip time distribution as a histogram. <code>plot_throughput()</code> Rate of completed trips in vehicles per hour. <code>plot_cumulative_curve()</code> Cumulative curve, either for network-wide data or for specific inflow and outflow detectors. <code>plot_space_time_diagram()</code> Space-time diagram based on <code>step_vehicles</code> data in tracked edges. <code>plot_trajectories()</code> Trajectories based on <code>step_vehicles</code> data in tracked edges. Use <code>lane_idx</code> to plot lane-specific data. <code>plot_fundamental_diagram()</code> Fundamental diagram based on <code>step_vehicles</code> data in tracked edges. <code>plot_rm_rate()</code> Metering rate for a ramp metering controller. <code>plot_rm_queuing()</code> On-ramp queue length/spillback for a ramp meter, if tracked. <code>plot_rm_rate_queuing()</code> Metering rate and queue length/spillback for a ramp meter, if tracking queuing. <code>plot_rm_rate_detector_data()</code> Metering rate and corresponding detector data. <code>plot_vsl_data()</code> Variable speed limit controller settings and average speeds on controlled edges. <code>plot_rg_data()</code> Number of vehicles diverted by a route guidance controller."},{"location":"8_plotting/#example-graphs","title":"Example Graphs","text":"<ol> <li> <p><code>plt.plot_vehicle_data(data_key\"no_vehicles\", plot_cumulative=True, show_events=False, save_fig=\"n_vehicles.png\")</code> </p> </li> <li> <p><code>plt.plot_junc_flows(junc_id=\"utsc\", show_events=False, save_fig=\"junc_flows.png\")</code> </p> </li> <li> <p><code>plt.plot_tl_colours(junc_id=\"utsc\", save_fig=\"tl_colours.png\")</code> </p> </li> <li> <p><code>plt.plot_cumulative_curve(show_events=False, save_fig=\"cumulative_curve.png\")</code> </p> </li> <li> <p><code>plt.plot_trajectories([\"126730026\", \"1191885773\", \"1191885771\", \"126730171\", \"1191885772\", \"948542172\", \"70944365\", \"308977078\", \"1192621075\"], lane_idx=0, save_fig=\"trajectories.png\", show_events=False)</code> </p> </li> <li> <p><code>plt.plot_rm_rate(rm_id=\"crooswijk_meter\", show_events=False, save_fig=\"rm_rate.png\")</code> </p> </li> <li> <p><code>plt.plot_vsl_data(vsl_id=\"vsl\", show_events=False, save_fig=\"vsl_data.png\")</code> </p> </li> </ol>"},{"location":"9_example/","title":"Example","text":"<p>An complex example of TUD-SUMO with multiple controllers and object tracking can be found here, at github.com/tud-sumo/example, however, this example is broken down below.</p> <ol> <li> <p>Initialise the simulation object. <pre><code>my_sim = Simulation(scenario_name=\"A20_ITCS\", scenario_desc=\"Example traffic controllers, with ramp metering, a VSL controller and a route guidance controller.\")\n</code></pre></p> </li> <li> <p>Start the simulation and connection to TraCI and define the sumo config file. Here, metric units are used and a seed of 1 is given. <pre><code>my_sim.start(\"example_scenario/a20.sumocfg\", get_individual_vehicle_data=False, gui=False, seed=\"1\", units=\"metric\")\n</code></pre></p> </li> <li> <p>Add a tracked junction to the intersection with ID \"utsc\", which will track signal phases/times. <pre><code>my_sim.add_tracked_junctions({\"utsc\":\n                                 {\"flow_params\":\n                                     {\"inflow_detectors\": [\"utsc_n_in_1\", \"utsc_n_in_2\", \"utsc_w_in\", \"utsc_e_in\"],\n                                      \"outflow_detectors\": [\"utsc_w_out\", \"utsc_e_out\"],\n                                      \"vehicle_types\": [\"cars\", \"lorries\", \"motorcycles\", \"vans\"]\n                                     }\n                                 }\n                            })\n</code></pre></p> </li> <li> <p>Set traffic signal phases for the signal with ID 'utsc'. Here, there are 4 phases in the 60s cycle and the junction has 4 movements. <pre><code>my_sim.set_phases({\"utsc\":\n                      {\"phases\": [\"GGrr\", \"yyrr\", \"rrGG\", \"rryy\"],\n                       \"times\": [27, 3, 17, 3]\n                      }\n                 })\n</code></pre></p> </li> <li> <p>Track the junction 'crooswijk_meter', where there is an active ramp meter. Both meter and flow parameters are given to track meter specific variables (queue length, queue delay) and inflow/outflow. <pre><code>my_sim.add_tracked_junctions({\"crooswijk_meter\":\n                                {'meter_params':\n                                    {'min_rate': 200,\n                                     'max_rate': 2000,\n                                     'queue_detector': \"cw_ramp_queue\"\n                                    },\n                                 'flow_params':\n                                    {'inflow_detectors': [\"cw_ramp_inflow\", \"cw_rm_upstream\"],\n                                     'outflow_detectors': [\"cw_rm_downstream\"]\n                                    }\n                                }\n                            })\n</code></pre></p> </li> <li> <p>Add Route Guidance (RG) &amp; Variable Speed Limit (VSL) controllers. A RG controller is placed on the detector 'rerouter_det' and redirects drivers to the edge 'urban_out_w'. The VSL controller is active on edges with IDs '126729982', '126730069' and '126730059'. <pre><code>my_sim.add_controllers({\"rerouter\":\n                          {\"type\": \"RG\",\n                           \"detector_ids\": [\"rerouter_det\"],\n                           \"new_destination\": \"urban_out_w\",\n                           \"diversion_pct\": 1,\n                           \"highlight\": \"00FF00\"\n                          },\n                        \"vsl\":\n                          {\"type\": \"VSL\",\n                           \"geometry_ids\": [\"126729982\", \"126730069\", \"126730059\"]\n                          }\n                      })\n</code></pre></p> </li> <li> <p>Start tracking edges with IDs '126730026', '1191885773', '1191885771', '126730171' and '1191885772'. <pre><code>my_sim.add_tracked_edges([\"126730026\", \"1191885773\", \"1191885771\", \"126730171\", \"1191885772\"])\n</code></pre></p> </li> <li> <p>Add scheduled events from an 'example_incident.json' JSON file. <pre><code>my_sim.add_events(\"example_scenario/example_incident.json\")\n</code></pre></p> </li> <li> <p>Run a control loop, checking current step with <code>my_sim.curr_step</code>. <pre><code>n, sim_dur, new_veh_idx = 1 / my_sim.step_length, 500 / my_sim.step_length, 0\nwhile my_sim.curr_step &lt; sim_dur:\n</code></pre></p> </li> <li> <p>Perform (random) ramp metering control. <pre><code>    if my_sim.curr_step % 50 / my_sim.step_length == 0:\n        my_sim.set_tl_metering_rate(rm_id=\"crooswijk_meter\", metering_rate=randint(1200, 2000))\n        my_sim.set_tl_metering_rate(rm_id=\"a13_meter\", metering_rate=randint(1200, 2000))\n</code></pre></p> </li> <li> <p>Step through simulation. <pre><code>    my_sim.step_through(n_steps=n, pbar_max_steps=sim_dur)\n</code></pre></p> </li> <li> <p>Dynamically add new vehicles driving from 'urban_in_e' to 'urban_out_w'. <pre><code>    # Add new vehicles going from \"urban_in_e\" to \"urban_out_w\"\n    if my_sim.curr_step % 50 / my_sim.step_length == 0:\n        od_pair = (\"urban_in_e\", \"urban_out_w\")\n        my_sim.add_vehicle(vehicle_id=\"lorry_\"+str(new_veh_idx), vehicle_type=\"lorries\", routing=od_pair, origin_lane=\"first\")\n        my_sim.add_vehicle(vehicle_id=\"car_\"+str(new_veh_idx), vehicle_type=\"cars\", routing=od_pair)\n        new_veh_idx += 1\n</code></pre></p> </li> <li> <p>Dynamically create an incident with 2 vehicles at 100s, lasting for 100s. Edge speed is reduced to 5kmph. <pre><code>    if my_sim.curr_step == 100 / my_sim.step_length:\n        my_sim.cause_incident(100, n_vehicles=2, edge_speed=5)\n</code></pre></p> </li> <li> <p>Activate the RG and VSL controllers. <pre><code>    if my_sim.curr_step == 250 / my_sim.step_length:\n        # Activate controllers &amp; update UTSC phases.\n        my_sim.controllers[\"rerouter\"].activate()\n        my_sim.controllers[\"vsl\"].set_speed_limit(60)\n\n        my_sim.set_phases({\"utsc\": {\"phases\": [\"GGrr\", \"yyrr\", \"rrGG\", \"rryy\"], \"times\": [37, 3, 7, 3]}}, overwrite=False)\n</code></pre></p> </li> <li> <p>Once the control loop is complete, end the simulation then save (&amp; summarise) the resulting data. <pre><code>my_sim.end()\n\nmy_sim.save_data(\"example_data.json\")\nmy_sim.print_summary(save_file=\"example_summary.txt\")\n</code></pre></p> </li> </ol>"}]}